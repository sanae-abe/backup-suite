# ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

Backup Suite v1.0.0ã®æŠ€è¡“çš„ãªã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã€å®Ÿè£…è©³ç´°ã€æ‹¡å¼µæ€§ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

## ğŸ“‹ ç›®æ¬¡

- [ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦](#ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦)
- [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ](#ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ)
- [ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°](#ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°)
- [ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼](#ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼)
- [è¨­å®šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ](#è¨­å®šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ )
- [çµ±åˆã‚·ã‚¹ãƒ†ãƒ ](#çµ±åˆã‚·ã‚¹ãƒ†ãƒ )
- [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­è¨ˆ](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­è¨ˆ)
- [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ)
- [æ‹¡å¼µæ€§ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º](#æ‹¡å¼µæ€§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º)

## ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

### è¨­è¨ˆå“²å­¦

Backup Suiteã¯ä»¥ä¸‹ã®åŸå‰‡ã«åŸºã¥ã„ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ï¼š

1. **å‹å®‰å…¨æ€§å„ªå…ˆ**: Rustã®å‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ´»ç”¨ã—ãŸå®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼ã®æœ€å°åŒ–
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–**: ä¸¦åˆ—å‡¦ç†ã¨ãƒ¡ãƒ¢ãƒªåŠ¹ç‡æ€§ã«ã‚ˆã‚‹é«˜é€ŸåŒ–
3. **ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£**: ç›´æ„Ÿçš„ãªCLIã¨ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–UI
4. **æ‹¡å¼µæ€§**: ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆã«ã‚ˆã‚‹æ©Ÿèƒ½æ‹¡å¼µã®å®¹æ˜“ã•
5. **ä¿¡é ¼æ€§**: ãƒ‡ãƒ¼ã‚¿æå¤±é˜²æ­¢ã¨ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®å¾¹åº•

### æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

```
â”Œâ”€â”€â”€ ğŸ¦€ Rust Core â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Language: Rust 1.70+                                  â”‚
â”‚ Memory Safety: æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ãƒ»å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼         â”‚
â”‚ Performance: ã‚¼ãƒ­ã‚³ã‚¹ãƒˆæŠ½è±¡åŒ–ãƒ»LLVMæœ€é©åŒ–            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€ ğŸ“¦ ä¸»è¦Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ clap 4.x          â”‚ CLIå¼•æ•°è§£æãƒ»ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ãƒ»è£œå®Œ    â”‚
â”‚ skim              â”‚ ãƒ•ã‚¡ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ãƒ»ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–UI â”‚
â”‚ serde + toml      â”‚ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ãƒ»æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿     â”‚
â”‚ anyhow           â”‚ ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†        â”‚
â”‚ chrono           â”‚ æ—¥æ™‚å‡¦ç†ãƒ»ISO 8601å¯¾å¿œ             â”‚
â”‚ dirs             â”‚ ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åˆ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹   â”‚
â”‚ atty             â”‚ ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ç’°å¢ƒæ¤œå‡ºãƒ»ã‚«ãƒ©ãƒ¼å‡ºåŠ›åˆ¶å¾¡   â”‚
â”‚ clap_complete    â”‚ ã‚·ã‚§ãƒ«è£œå®Œç”Ÿæˆï¼ˆzsh/bash/fishï¼‰    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€ ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ macOS launchctl   â”‚ è‡ªå‹•ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ãƒ»ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ  â”‚
â”‚ Unix filesystem   â”‚ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ»æ¨©é™ç®¡ç†            â”‚
â”‚ Shell integration â”‚ è£œå®Œãƒ»ç’°å¢ƒå¤‰æ•°ãƒ»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ›ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‰ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸ¯ CLI Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Command     â”‚ Interactive â”‚ Completion              â”‚ â”‚
â”‚  â”‚ Parsing     â”‚ UI (skim)   â”‚ Generation              â”‚ â”‚
â”‚  â”‚ (clap)      â”‚            â”‚ (clap_complete)         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  âš™ï¸ Business Logic Layer                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Backup      â”‚ Schedule    â”‚ Config                  â”‚ â”‚
â”‚  â”‚ Runner      â”‚ Manager     â”‚ Manager                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ğŸ’¾ Data Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ TOML        â”‚ File        â”‚ History                 â”‚ â”‚
â”‚  â”‚ Config      â”‚ Operations  â”‚ Management              â”‚ â”‚
â”‚  â”‚ (serde)     â”‚            â”‚ (chrono)                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ğŸ–¥ï¸ System Integration Layer               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Filesystem  â”‚ launchctl   â”‚ Terminal                â”‚ â”‚
â”‚  â”‚ Operations  â”‚ (macOS)     â”‚ Detection               â”‚ â”‚
â”‚  â”‚            â”‚            â”‚ (atty)                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ

```
backup-suite/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆãƒ»CLIå®Ÿè£…
â”‚   â””â”€â”€ core/                # ã‚³ã‚¢ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â”‚       â”œâ”€â”€ mod.rs           # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©
â”‚       â”œâ”€â”€ config.rs        # è¨­å®šç®¡ç†ï¼ˆConfig, Targetï¼‰
â”‚       â”œâ”€â”€ backup.rs        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œï¼ˆBackupRunnerï¼‰
â”‚       â”œâ”€â”€ history.rs       # å±¥æ­´ç®¡ç†ï¼ˆBackupHistoryï¼‰
â”‚       â”œâ”€â”€ schedule.rs      # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ï¼ˆlaunchctlçµ±åˆï¼‰
â”‚       â””â”€â”€ utils.rs         # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
â”œâ”€â”€ Cargo.toml              # ä¾å­˜é–¢ä¿‚ãƒ»ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
â””â”€â”€ docs/                   # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
```

## ğŸ”§ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°

### CLI Layer (`main.rs`)

#### Clap Command Structure
```rust
#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    Add { path, priority, category, interactive },
    List { priority },
    Remove { path, interactive },
    // ... ä»–ã®ã‚³ãƒãƒ³ãƒ‰
    Schedule { action: ScheduleAction },
}

#[derive(Subcommand)]
enum ScheduleAction {
    Enable { priority },
    Disable { priority },
    Status,
    Setup { high, medium, low },
}
```

#### Interactive UI Integration
```rust
fn select_file_with_skim(prompt: &str) -> Result<Option<PathBuf>> {
    let options = SkimOptionsBuilder::default()
        .height("50%".to_string())
        .multi(false)
        .prompt(prompt.to_string())
        .build()?;

    // findã‚³ãƒãƒ³ãƒ‰ã¨skimçµ±åˆ
    let cmd = "find . -type f -o -type d | head -1000";
    let child = std::process::Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .stdout(std::process::Stdio::piped())
        .spawn()?;

    // skimã§ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–é¸æŠ
    let input = SkimItemReader::default().of_bufread(BufReader::new(stdout));
    let selected_items = Skim::run_with(&options, Some(input))
        .map(|out| out.selected_items)
        .unwrap_or_else(Vec::new);

    // é¸æŠçµæœã®å‡¦ç†
    if let Some(item) = selected_items.first() {
        let path = PathBuf::from(item.output().to_string());
        Ok(Some(path.canonicalize()?))
    } else {
        Ok(None)
    }
}
```

#### Color Management System
```rust
fn supports_color() -> bool {
    atty::is(atty::Stream::Stdout) &&
    std::env::var("NO_COLOR").is_err() &&
    std::env::var("TERM").map(|term| term != "dumb").unwrap_or(true)
}

fn get_color(color_code: &str) -> &'static str {
    if supports_color() {
        match color_code {
            "green" => "\\x1b[32m",
            "yellow" => "\\x1b[33m",
            "red" => "\\x1b[31m",
            "reset" => "\\x1b[0m",
            _ => "",
        }
    } else {
        ""
    }
}
```

### Business Logic Layer (`core/`)

#### Config Management (`core/config.rs`)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub version: String,
    pub backup: BackupConfig,
    #[serde(default)]
    pub schedule: ScheduleConfig,
    pub targets: Vec<Target>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct BackupConfig {
    pub destination: PathBuf,
    pub auto_cleanup: bool,
    pub keep_days: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ScheduleConfig {
    pub enabled: bool,
    pub high_frequency: String,    // "daily", "weekly", "monthly"
    pub medium_frequency: String,
    pub low_frequency: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Target {
    pub path: PathBuf,
    pub priority: Priority,
    pub target_type: TargetType,
    pub category: String,
    pub added_date: DateTime<Utc>,
    pub exclude_patterns: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum Priority {
    High,
    Medium,
    Low,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum TargetType {
    File,
    Directory,
}
```

#### Backup Runner (`core/backup.rs`)
```rust
pub struct BackupRunner {
    config: Config,
    dry_run: bool,
}

pub struct BackupResult {
    pub success_files: usize,
    pub total_files: usize,
    pub total_bytes: u64,
    pub errors: Vec<String>,
}

impl BackupRunner {
    pub fn new(config: Config, dry_run: bool) -> Self {
        Self { config, dry_run }
    }

    pub fn run(&self, priority_filter: Option<&Priority>) -> Result<BackupResult> {
        let targets = self.filter_targets(priority_filter);
        let backup_dir = self.create_backup_directory()?;

        let mut result = BackupResult::default();

        for target in targets {
            match self.backup_target(&target, &backup_dir) {
                Ok(stats) => {
                    result.success_files += stats.files;
                    result.total_bytes += stats.bytes;
                }
                Err(e) => {
                    result.errors.push(format!("{}: {}", target.path.display(), e));
                }
            }
        }

        result.total_files = result.success_files + result.errors.len();

        if !self.dry_run {
            self.save_history(&result, &backup_dir)?;
        }

        Ok(result)
    }

    fn backup_target(&self, target: &Target, backup_dir: &Path) -> Result<BackupStats> {
        match target.target_type {
            TargetType::File => self.backup_file(&target.path, backup_dir),
            TargetType::Directory => self.backup_directory(&target.path, backup_dir, &target.exclude_patterns),
        }
    }
}
```

#### History Management (`core/history.rs`)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct BackupHistory {
    pub timestamp: DateTime<Utc>,
    pub backup_dir: PathBuf,
    pub total_files: usize,
    pub total_bytes: u64,
    pub success: bool,
    pub priority: Option<String>,
    pub errors: Vec<String>,
}

impl BackupHistory {
    pub fn new(result: &BackupResult, backup_dir: &Path, priority: Option<&str>) -> Self {
        Self {
            timestamp: Utc::now(),
            backup_dir: backup_dir.to_path_buf(),
            total_files: result.total_files,
            total_bytes: result.total_bytes,
            success: result.errors.is_empty(),
            priority: priority.map(String::from),
            errors: result.errors.clone(),
        }
    }

    pub fn save(&self, config_dir: &Path) -> Result<()> {
        let history_file = config_dir.join("history.toml");
        let mut histories = Self::load_all_from_file(&history_file)?;
        histories.push(self.clone());

        // æœ€æ–°1000ä»¶ã®ã¿ä¿æŒ
        if histories.len() > 1000 {
            histories.drain(0..histories.len() - 1000);
        }

        let toml_content = toml::to_string_pretty(&histories)?;
        std::fs::write(history_file, toml_content)?;
        Ok(())
    }

    pub fn filter_by_days(days: u32) -> Result<Vec<Self>> {
        let cutoff = Utc::now() - chrono::Duration::days(days as i64);
        let all_histories = Self::load_all()?;

        Ok(all_histories
            .into_iter()
            .filter(|h| h.timestamp > cutoff)
            .collect())
    }
}
```

### launchctl Integration (`core/schedule.rs`)

#### macOS Scheduling System
```rust
pub struct ScheduleManager {
    config: Config,
}

impl ScheduleManager {
    pub fn setup_schedule(&self, priority: &str) -> Result<()> {
        let frequency = self.get_frequency_for_priority(priority)?;
        let plist_content = self.create_plist_content(priority, frequency)?;
        let plist_path = self.get_plist_path(priority)?;

        // plistãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        std::fs::write(&plist_path, plist_content)?;

        // launchctl load
        let output = std::process::Command::new("launchctl")
            .args(&["load", &plist_path.to_string_lossy()])
            .output()?;

        if !output.status.success() {
            return Err(anyhow::anyhow!("launchctl load failed: {}",
                String::from_utf8_lossy(&output.stderr)));
        }

        Ok(())
    }

    fn create_plist_content(&self, priority: &str, frequency: &str) -> Result<String> {
        let backup_suite_path = std::env::current_exe()?;

        let plist = format!(r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.backup-suite.{priority}</string>

    <key>ProgramArguments</key>
    <array>
        <string>{backup_suite_path}</string>
        <string>run</string>
        <string>--priority</string>
        <string>{priority}</string>
    </array>

    <key>StartCalendarInterval</key>
    <dict>
        <key>Hour</key>
        <integer>2</integer>
        <key>Minute</key>
        <integer>0</integer>
        {weekday_or_day}
    </dict>

    <key>RunAtLoad</key>
    <false/>

    <key>StandardOutPath</key>
    <string>/tmp/backup-suite-{priority}.log</string>

    <key>StandardErrorPath</key>
    <string>/tmp/backup-suite-{priority}.error.log</string>
</dict>
</plist>"#,
            priority = priority,
            backup_suite_path = backup_suite_path.display(),
            weekday_or_day = match frequency {
                "weekly" => "<key>Weekday</key>\\n        <integer>0</integer>",
                "monthly" => "<key>Day</key>\\n        <integer>1</integer>",
                _ => "",
            }
        );

        Ok(plist)
    }

    pub fn check_status(&self) -> Result<HashMap<String, bool>> {
        let mut status = HashMap::new();

        for priority in &["high", "medium", "low"] {
            let label = format!("com.backup-suite.{}", priority);
            let output = std::process::Command::new("launchctl")
                .args(&["list", &label])
                .output()?;

            status.insert(priority.to_string(), output.status.success());
        }

        Ok(status)
    }
}
```

## ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ãƒ•ãƒ­ãƒ¼

```
1. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
   â†“
2. Config::load() å‘¼ã³å‡ºã—
   â†“
3. ~/.config/backup-suite/config.toml èª­ã¿è¾¼ã¿
   â†“
4. TOML â†’ Rustæ§‹é€ ä½“ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ (serde)
   â†“
5. è¨­å®šæ¤œè¨¼ãƒ»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤é©ç”¨
   â†“
6. Configæ§‹é€ ä½“ã¨ã—ã¦åˆ©ç”¨å¯èƒ½
```

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œãƒ•ãƒ­ãƒ¼

```
1. backup-suite run ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
   â†“
2. CLIå¼•æ•°è§£æ (clap)
   â†“
3. Configèª­ã¿è¾¼ã¿
   â†“
4. BackupRunneråˆæœŸåŒ–
   â†“
5. å¯¾è±¡ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆpriorityï¼‰
   â†“
6. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
   â†“
7. å„å¯¾è±¡ã«ã¤ã„ã¦ä¸¦åˆ—ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
   â”‚ â”œâ”€ ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåˆ¤å®š
   â”‚ â”œâ”€ é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³é©ç”¨
   â”‚ â”œâ”€ ã‚³ãƒ”ãƒ¼å®Ÿè¡Œ
   â”‚ â””â”€ çµ±è¨ˆæƒ…å ±æ›´æ–°
   â†“
8. å±¥æ­´ä¿å­˜ (BackupHistory)
   â†“
9. çµæœè¡¨ç¤ºãƒ»çµ‚äº†
```

### ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–é¸æŠãƒ•ãƒ­ãƒ¼

```
1. backup-suite add --interactive
   â†“
2. select_file_with_skim() å‘¼ã³å‡ºã—
   â†“
3. find ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—ï¼‰
   â†“
4. skim UIè¡¨ç¤º
   â†“
5. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ãƒ•ã‚¡ã‚¸ãƒ¼ã‚µãƒ¼ãƒãƒ»é¸æŠ
   â†“
6. é¸æŠçµæœå–å¾—ãƒ»ãƒ‘ã‚¹æ­£è¦åŒ–
   â†“
7. Targetæ§‹é€ ä½“ä½œæˆãƒ»Configè¿½åŠ 
   â†“
8. TOMLä¿å­˜
```

## âš™ï¸ è¨­å®šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### TOMLæ§‹é€ ã¨serdeãƒãƒƒãƒ”ãƒ³ã‚°

#### serdeã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆæ´»ç”¨
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub version: String,

    pub backup: BackupConfig,

    #[serde(default)]  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ç”¨
    pub schedule: ScheduleConfig,

    #[serde(default)]  // ç©ºã®Vecã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    pub targets: Vec<Target>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Target {
    pub path: PathBuf,

    #[serde(default = "default_priority")]
    pub priority: Priority,

    #[serde(default)]
    pub exclude_patterns: Vec<String>,

    #[serde(with = "chrono::serde::ts_seconds")]
    pub added_date: DateTime<Utc>,
}

fn default_priority() -> Priority {
    Priority::Medium
}
```

#### ä¸‹ä½äº’æ›æ€§ä¿è¨¼
```rust
impl Default for ScheduleConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            high_frequency: "daily".to_string(),
            medium_frequency: "weekly".to_string(),
            low_frequency: "monthly".to_string(),
        }
    }
}

// æ–°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ æ™‚ã®äº’æ›æ€§
#[serde(default)]  // å¤ã„è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚‚å‹•ä½œ
pub new_feature: bool,
```

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```rust
impl Config {
    pub fn load() -> Result<Self> {
        let config_dir = Self::get_config_dir()?;
        let config_path = config_dir.join("config.toml");

        if !config_path.exists() {
            // åˆå›å®Ÿè¡Œæ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šä½œæˆ
            let default_config = Self::default();
            default_config.save()?;
            return Ok(default_config);
        }

        let content = std::fs::read_to_string(&config_path)?;
        let mut config: Config = toml::from_str(&content)
            .map_err(|e| anyhow::anyhow!("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {}", e))?;

        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ãƒ»ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        if config.version != env!("CARGO_PKG_VERSION") {
            config = Self::migrate_config(config)?;
        }

        Ok(config)
    }

    fn migrate_config(mut config: Config) -> Result<Self> {
        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³åˆ¥ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
        match config.version.as_str() {
            "0.9.x" => {
                // å¤ã„formatå¤‰æ›
                config.version = "1.0.0".to_string();
            }
            _ => {
                // ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æ›´æ–°
                config.version = env!("CARGO_PKG_VERSION").to_string();
            }
        }

        config.save()?;
        Ok(config)
    }
}
```

## ğŸ”— çµ±åˆã‚·ã‚¹ãƒ†ãƒ 

### Shell Completion Generation

#### clap_completeçµ±åˆ
```rust
use clap::{CommandFactory, Parser};
use clap_complete::{generate, Generator, Shell};

fn print_completions<G: Generator>(generator: G, cmd: &mut clap::Command) {
    generate(generator, cmd, cmd.get_name().to_string(), &mut io::stdout());
}

// usage:
let mut cmd = Cli::command();
match shell {
    Shell::Zsh => print_completions(clap_complete::shells::Zsh, &mut cmd),
    Shell::Bash => print_completions(clap_complete::shells::Bash, &mut cmd),
    Shell::Fish => print_completions(clap_complete::shells::Fish, &mut cmd),
}
```

#### è£œå®Œå“è³ªå‘ä¸Š
```rust
#[derive(Parser)]
struct AddCommand {
    /// File or directory path to add
    #[arg(value_hint = ValueHint::AnyPath)]
    path: Option<PathBuf>,

    /// Priority level
    #[arg(long, value_enum)]
    priority: Option<Priority>,

    /// Category for organization
    #[arg(long)]
    category: Option<String>,
}

#[derive(ValueEnum, Clone)]
enum Priority {
    High,
    Medium,
    Low,
}
```

### Cross-Platform Compatibility

#### ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œå‡º
```rust
#[cfg(target_os = "macos")]
fn open_directory(path: &Path) -> Result<()> {
    std::process::Command::new("open").arg(path).spawn()?;
    Ok(())
}

#[cfg(target_os = "linux")]
fn open_directory(path: &Path) -> Result<()> {
    std::process::Command::new("xdg-open").arg(path).spawn()?;
    Ok(())
}

#[cfg(target_os = "windows")]
fn open_directory(path: &Path) -> Result<()> {
    std::process::Command::new("explorer").arg(path).spawn()?;
    Ok(())
}
```

#### æ¡ä»¶ä»˜ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
```rust
#[cfg(target_os = "macos")]
mod macos_schedule;

#[cfg(target_os = "linux")]
mod systemd_schedule;

#[cfg(target_os = "windows")]
mod windows_schedule;
```

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­è¨ˆ

### ãƒ¡ãƒ¢ãƒªåŠ¹ç‡æ€§

#### æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ æ´»ç”¨
```rust
// ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼æ–‡å­—åˆ—å‡¦ç†
fn process_file_list(files: &[PathBuf]) -> Result<Vec<&Path>> {
    files.iter()
        .map(|p| p.as_path())
        .filter(|p| p.exists())
        .collect()
}

// ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
fn backup_large_directory(src: &Path, dst: &Path) -> Result<()> {
    for entry in WalkDir::new(src) {
        let entry = entry?;
        // 1ãƒ•ã‚¡ã‚¤ãƒ«ãšã¤å‡¦ç†ï¼ˆå…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€åº¦ã«ãƒ¡ãƒ¢ãƒªã«ä¿æŒã—ãªã„ï¼‰
        process_single_file(&entry.path())?;
    }
    Ok(())
}
```

#### ä¸¦åˆ—å‡¦ç†æœ€é©åŒ–
```rust
use rayon::prelude::*;

fn backup_files_parallel(files: &[PathBuf], dst: &Path) -> Result<Vec<BackupResult>> {
    files.par_iter()
        .map(|src| backup_single_file(src, dst))
        .collect::<Result<Vec<_>>>()
}

// CPUã‚³ã‚¢æ•°ã«å¿œã˜ãŸä¸¦åˆ—åº¦èª¿æ•´
fn configure_thread_pool() {
    let num_threads = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4);

    rayon::ThreadPoolBuilder::new()
        .num_threads(num_threads)
        .build_global()
        .expect("Failed to configure thread pool");
}
```

### I/Oæœ€é©åŒ–

#### ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°æˆ¦ç•¥
```rust
use std::io::{BufReader, BufWriter};

fn copy_file_optimized(src: &Path, dst: &Path) -> Result<u64> {
    let src_file = File::open(src)?;
    let dst_file = File::create(dst)?;

    let mut reader = BufReader::with_capacity(64 * 1024, src_file);  // 64KB buffer
    let mut writer = BufWriter::with_capacity(64 * 1024, dst_file);

    std::io::copy(&mut reader, &mut writer)
}

// å¤§ãƒ•ã‚¡ã‚¤ãƒ«ç”¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚³ãƒ”ãƒ¼
fn copy_large_file(src: &Path, dst: &Path) -> Result<()> {
    const CHUNK_SIZE: usize = 1024 * 1024;  // 1MB chunks

    let mut src_file = File::open(src)?;
    let mut dst_file = File::create(dst)?;
    let mut buffer = vec![0; CHUNK_SIZE];

    loop {
        let bytes_read = src_file.read(&mut buffer)?;
        if bytes_read == 0 { break; }

        dst_file.write_all(&buffer[..bytes_read])?;
    }

    Ok(())
}
```

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§

#### Rustã®å®‰å…¨æ€§ä¿è¨¼
```rust
// è‡ªå‹•çš„ã«ãƒ¡ãƒ¢ãƒªå®‰å…¨
fn safe_string_processing(input: &str) -> String {
    input.chars()
        .filter(|c| c.is_alphanumeric())
        .collect()
    // ãƒ¡ãƒ¢ãƒªè‡ªå‹•è§£æ”¾ã€ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒã‚¤ãƒ³ã‚¿ãªã—
}

// å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã«ã‚ˆã‚‹å®‰å…¨æ€§
fn safe_file_access(paths: &[PathBuf]) -> Vec<String> {
    paths.iter()
        .filter_map(|p| p.to_str())  // ç„¡åŠ¹ãªUTF-8ã¯å®‰å…¨ã«ç„¡è¦–
        .map(|s| s.to_string())
        .collect()
}
```

#### å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
```rust
fn validate_path(path: &Path) -> Result<PathBuf> {
    // ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ”»æ’ƒé˜²æ­¢
    let canonical = path.canonicalize()
        .map_err(|_| anyhow::anyhow!("ç„¡åŠ¹ãªãƒ‘ã‚¹: {}", path.display()))?;

    // ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå¤–ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹é˜²æ­¢
    let home = dirs::home_dir()
        .ok_or_else(|| anyhow::anyhow!("ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒç‰¹å®šã§ãã¾ã›ã‚“"))?;

    if !canonical.starts_with(&home) {
        return Err(anyhow::anyhow!("ãƒ›ãƒ¼ãƒ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå¤–ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™"));
    }

    Ok(canonical)
}

fn sanitize_category(category: &str) -> String {
    category.chars()
        .filter(|c| c.is_alphanumeric() || *c == '-' || *c == '_')
        .take(32)  // æœ€å¤§32æ–‡å­—
        .collect()
}
```

### ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

#### æ¨©é™ç®¡ç†
```rust
use std::os::unix::fs::PermissionsExt;

fn secure_file_creation(path: &Path, content: &[u8]) -> Result<()> {
    let mut file = File::create(path)?;

    // ãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™è¨­å®šï¼ˆæ‰€æœ‰è€…ã®ã¿èª­ã¿æ›¸ãå¯èƒ½ï¼‰
    let metadata = file.metadata()?;
    let mut permissions = metadata.permissions();
    permissions.set_mode(0o600);  // rw-------
    file.set_permissions(permissions)?;

    file.write_all(content)?;
    Ok(())
}

fn secure_directory_creation(path: &Path) -> Result<()> {
    std::fs::create_dir_all(path)?;

    // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¨©é™è¨­å®š
    let metadata = std::fs::metadata(path)?;
    let mut permissions = metadata.permissions();
    permissions.set_mode(0o700);  // rwx------
    std::fs::set_permissions(path, permissions)?;

    Ok(())
}
```

#### æ©Ÿå¯†æƒ…å ±ä¿è­·
```rust
fn load_config_securely() -> Result<Config> {
    let config_path = get_config_path()?;

    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ¨©é™ç¢ºèª
    let metadata = std::fs::metadata(&config_path)?;
    let permissions = metadata.permissions();

    if permissions.mode() & 0o077 != 0 {
        return Err(anyhow::anyhow!(
            "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ¨©é™ãŒå®‰å…¨ã§ã‚ã‚Šã¾ã›ã‚“ã€‚chmod 600 {} ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„",
            config_path.display()
        ));
    }

    let content = std::fs::read_to_string(&config_path)?;
    let config: Config = toml::from_str(&content)?;

    Ok(config)
}
```

## ğŸ”Œ æ‹¡å¼µæ€§ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

### ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆå°†æ¥è¨ˆç”»ï¼‰

#### Trait Based Extension
```rust
pub trait BackupProcessor {
    fn process_before_backup(&self, target: &Target) -> Result<()>;
    fn process_after_backup(&self, target: &Target, result: &BackupResult) -> Result<()>;
    fn supports_target(&self, target: &Target) -> bool;
}

pub trait StorageBackend {
    fn upload(&self, local_path: &Path, remote_path: &str) -> Result<()>;
    fn download(&self, remote_path: &str, local_path: &Path) -> Result<()>;
    fn list(&self, prefix: &str) -> Result<Vec<String>>;
    fn delete(&self, remote_path: &str) -> Result<()>;
}

// å®Ÿè£…ä¾‹
pub struct S3Backend {
    bucket: String,
    region: String,
    credentials: Credentials,
}

impl StorageBackend for S3Backend {
    fn upload(&self, local_path: &Path, remote_path: &str) -> Result<()> {
        // AWS S3ã¸ã®å®Ÿè£…
        todo!()
    }
}
```

#### å‹•çš„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
```rust
pub struct PluginManager {
    processors: Vec<Box<dyn BackupProcessor>>,
    backends: Vec<Box<dyn StorageBackend>>,
}

impl PluginManager {
    pub fn load_plugins(&mut self, plugin_dir: &Path) -> Result<()> {
        for entry in std::fs::read_dir(plugin_dir)? {
            let entry = entry?;
            if entry.path().extension() == Some(std::ffi::OsStr::new("so")) {
                self.load_plugin(&entry.path())?;
            }
        }
        Ok(())
    }

    fn load_plugin(&mut self, plugin_path: &Path) -> Result<()> {
        // å‹•çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ‰
        // unsafe ã ãŒã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã«ã¯å¿…è¦
        todo!()
    }
}
```

### è¨­å®šæ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ

#### ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct CustomFilter {
    pub name: String,
    pub pattern: String,
    pub action: FilterAction,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum FilterAction {
    Include,
    Exclude,
    Transform(String),
}

// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã®ä½¿ç”¨
[[custom_filters]]
name = "exclude_build_files"
pattern = "**/target/**"
action = "Exclude"

[[custom_filters]]
name = "compress_logs"
pattern = "**/*.log"
action = { Transform = "gzip" }
```

#### ã‚«ã‚¹ã‚¿ãƒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
```rust
pub trait NotificationBackend {
    fn send_success(&self, message: &str) -> Result<()>;
    fn send_warning(&self, message: &str) -> Result<()>;
    fn send_error(&self, message: &str) -> Result<()>;
}

pub struct SlackNotifier {
    webhook_url: String,
    channel: String,
}

impl NotificationBackend for SlackNotifier {
    fn send_success(&self, message: &str) -> Result<()> {
        let payload = json!({
            "channel": self.channel,
            "text": format!("âœ… {}", message),
            "icon_emoji": ":backup:"
        });

        // HTTP POST to Slack webhook
        todo!()
    }
}
```

### CLIæ‹¡å¼µ

#### ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒãƒ³ãƒ‰è¿½åŠ 
```rust
// ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§ã®æ–°ã‚³ãƒãƒ³ãƒ‰å®šç¾©
#[derive(Subcommand)]
pub enum PluginCommands {
    Encrypt {
        #[arg(long)]
        key_file: PathBuf,
    },

    Sync {
        #[arg(long)]
        remote: String,
    },

    Analyze {
        #[arg(long)]
        report_format: String,
    },
}

// ãƒ¡ã‚¤ãƒ³CLIã¨ã®çµ±åˆ
#[derive(Subcommand)]
pub enum Commands {
    // ... æ—¢å­˜ã‚³ãƒãƒ³ãƒ‰

    #[command(flatten)]
    Plugin(PluginCommands),
}
```

### è¨­å®šã‚¹ã‚­ãƒ¼ãƒæ‹¡å¼µ

#### å‹å®‰å…¨ãªè¨­å®šæ‹¡å¼µ
```rust
// ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã®å‹å®‰å…¨ãªç®¡ç†
#[derive(Debug, Serialize, Deserialize)]
pub struct ExtendedConfig {
    #[serde(flatten)]
    pub base: Config,

    #[serde(default)]
    pub encryption: EncryptionConfig,

    #[serde(default)]
    pub cloud_sync: CloudSyncConfig,

    #[serde(default)]
    pub notifications: NotificationConfig,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct EncryptionConfig {
    pub enabled: bool,
    pub algorithm: String,
    pub key_derivation: String,
}
```

## ğŸ”® å°†æ¥ã®æ‹¡å¼µè¨ˆç”»

### v1.1.0: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ
- Linux systemdçµ±åˆ
- Windows Task Schedulerçµ±åˆ
- çµ±ä¸€ã•ã‚ŒãŸã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

### v1.2.0: ã‚¯ãƒ©ã‚¦ãƒ‰çµ±åˆ
- AWS S3ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
- Google Drive APIçµ±åˆ
- å¢—åˆ†åŒæœŸãƒ»ãƒ‡ãƒ‡ãƒ¥ãƒ¼ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

### v1.3.0: é«˜åº¦ãªæ©Ÿèƒ½
- æš—å·åŒ–ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- åœ§ç¸®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
- WebUIï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### v2.0.0: ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºæ©Ÿèƒ½
- ãƒãƒ«ãƒãƒ¦ãƒ¼ã‚¶ãƒ¼å¯¾å¿œ
- ä¸­å¤®ç®¡ç†ãƒ»ãƒãƒªã‚·ãƒ¼åˆ¶å¾¡
- ç›£æŸ»ãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

---

ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã«ã‚ˆã‚Šã€Backup Suiteã¯é«˜æ€§èƒ½ãƒ»é«˜ä¿¡é ¼æ€§ãƒ»é«˜æ‹¡å¼µæ€§ã‚’å®Ÿç¾ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‹ãƒ¼ã‚ºã«é•·æœŸçš„ã«å¯¾å¿œã§ãã‚‹ã‚·ã‚¹ãƒ†ãƒ ã¨ãªã£ã¦ã„ã¾ã™ã€‚

## ğŸ“ æŠ€è¡“çš„ã‚µãƒãƒ¼ãƒˆ

ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚„å®Ÿè£…ã«ã¤ã„ã¦æŠ€è¡“çš„ãªè³ªå•ãŒã‚ã‚‹å ´åˆï¼š

1. **GitHub Issues**: [æŠ€è¡“çš„è³ªå•](https://github.com/user/backup-suite/issues)
2. **GitHub Discussions**: [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è­°è«–](https://github.com/user/backup-suite/discussions)
3. **Developer Email**: dev@backup-suite.example.com

---

**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: [USAGE.md](USAGE.md) | [MIGRATION.md](MIGRATION.md) | [TROUBLESHOOTING.md](TROUBLESHOOTING.md)