--- src/crypto/encryption.rs
+++ replace EncryptionEngine::decrypt_stream -> Result<u64> with Ok(1)
@@ -267,56 +267,17 @@
     #[allow(deprecated)]
     pub fn decrypt_stream<R: Read, W: Write>(
         &self,
         mut reader: R,
         mut writer: W,
         master_key: &MasterKey,
     ) -> Result<u64> {
         // ヘッダー情報を読み取り
-        let mut nonce_bytes = [0u8; 12];
-        let mut salt = [0u8; 16];
-        reader.read_exact(&mut nonce_bytes)?;
-        reader.read_exact(&mut salt)?;
-
-        let key = Key::<Aes256Gcm>::from_slice(master_key.as_bytes());
-        let cipher = Aes256Gcm::new(key);
-
-        let mut total_decrypted = 0u64;
-        let mut chunk_index = 0u64;
-
-        loop {
-            // チャンクサイズを読み取り
-            let mut chunk_size_bytes = [0u8; 4];
-            match reader.read_exact(&mut chunk_size_bytes) {
-                Ok(_) => {}
-                Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => break,
-                Err(e) => return Err(BackupError::IoError(e)),
-            }
-
-            let chunk_size = u32::from_le_bytes(chunk_size_bytes) as usize;
-            let mut chunk_data = vec![0u8; chunk_size];
-            reader.read_exact(&mut chunk_data)?;
-
-            // チャンク毎のナンスを再生成（u64カウンター）
-            let mut chunk_nonce = nonce_bytes;
-            chunk_nonce[4..12].copy_from_slice(&chunk_index.to_le_bytes());
-
-            #[allow(deprecated)]
-            let nonce = Nonce::from_slice(&chunk_nonce);
-            let plaintext = cipher
-                .decrypt(nonce, chunk_data.as_ref())
-                .map_err(|e| BackupError::EncryptionError(format!("チャンク復号化エラー: {e}")))?;
-
-            writer.write_all(&plaintext)?;
-            total_decrypted += plaintext.len() as u64;
-            chunk_index += 1;
-        }
-
-        Ok(total_decrypted)
+        Ok(1) /* ~ changed by cargo-mutants ~ */
     }
 }
 
 impl Default for EncryptionEngine {
     fn default() -> Self {
         Self::new(EncryptionConfig::default())
     }
 }
