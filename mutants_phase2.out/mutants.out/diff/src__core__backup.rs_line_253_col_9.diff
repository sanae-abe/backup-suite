--- src/core/backup.rs
+++ replace BackupRunner::run -> Result<BackupResult> with Ok(Default::default())
@@ -245,520 +245,17 @@
     /// let mut runner = BackupRunner::new(config, false);
     /// let result = runner.run(Some(&Priority::High), None).unwrap();
     /// ```
     pub fn run(
         &mut self,
         priority_filter: Option<&Priority>,
         category_filter: Option<&str>,
     ) -> Result<BackupResult> {
-        let user = AuditLog::current_user();
-        let target_desc = format!("priority={priority_filter:?}, category={category_filter:?}");
-
-        // ç›£æŸ»ãƒ­ã‚°: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é–‹å§‹
-        if let Some(ref mut audit_log) = self.audit_log {
-            let _ = audit_log
-                .log(AuditEvent::backup_started(&target_desc, &user))
-                .map_err(|e| eprintln!("è­¦å‘Š: ç›£æŸ»ãƒ­ã‚°ã®è¨˜éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}"));
-        }
-
-        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ã‚’ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆå„ªå…ˆåº¦ â†’ ã‚«ãƒ†ã‚´ãƒªã®é †ï¼‰
-        let mut targets: Vec<&Target> = if let Some(priority) = priority_filter {
-            self.config.filter_by_priority(priority)
-        } else {
-            self.config.targets.iter().collect()
-        };
-
-        // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ã®é©ç”¨
-        if let Some(category) = category_filter {
-            targets.retain(|t| t.category == category);
-        }
-
-        if targets.is_empty() {
-            return Ok(BackupResult::new());
-        }
-
-        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æº–å‚™ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å/ã‚«ãƒ†ã‚´ãƒªéšå±¤æ§‹é€ ï¼‰
-        let dest_base = &self.config.backup.destination;
-        let now = chrono::Local::now();
-        let timestamp = now.format("%Y%m%d_%H%M%S");
-        let backup_name = format!("backup_{timestamp}");
-        let backup_base = dest_base.join(&backup_name);
-
-        // æš—å·åŒ–ãŒæœ‰åŠ¹ãªå ´åˆã€KeyManagerã¨master keyã‚’æº–å‚™
-        let (_key_manager, master_key, encryption_salt) =
-            if self.enable_encryption && self.password.is_some() {
-                let km = KeyManager::default();
-                let password = self.password.as_ref().ok_or_else(|| {
-                    anyhow::anyhow!("æš—å·åŒ–ãŒæœ‰åŠ¹ã§ã™ãŒãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
-                })?;
-                let (mk, salt) = km
-                    .create_master_key(password)
-                    .context("ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ç”Ÿæˆå¤±æ•—")?;
-                (Some(km), Some(Arc::new(mk)), Some(salt))
-            } else {
-                (None, None, None)
-            };
-
-        // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’åé›†
-        let mut all_files: Vec<(PathBuf, PathBuf)> = Vec::new();
-
-        // ã‚¹ãƒ”ãƒŠãƒ¼è¡¨ç¤ºï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åé›†ä¸­ï¼‰
-        let collection_spinner = if self.show_progress {
-            let spinner = BackupProgress::new_spinner();
-            spinner.set_message("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†ä¸­...");
-            Some(spinner)
-        } else {
-            None
-        };
-
-        for target in &targets {
-            // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚«ãƒ†ã‚´ãƒªã‚’ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã«ä½¿ç”¨
-            // ï¼ˆã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ã¯221-223è¡Œã§æ—¢ã«é©ç”¨æ¸ˆã¿ï¼‰
-            let category = target.category.clone();
-            let backup_dir = backup_base.join(&category);
-
-            // ã‚«ãƒ†ã‚´ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
-            std::fs::create_dir_all(&backup_dir)
-                .context("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆå¤±æ•—: backup_dir.display()".to_string())?;
-
-            // FileFilterã®æº–å‚™
-            let filter = if !target.exclude_patterns.is_empty() {
-                match FileFilter::new(&target.exclude_patterns) {
-                    Ok(f) => Some(f),
-                    Err(e) => {
-                        eprintln!("è­¦å‘Š: é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡¦ç†ã«å¤±æ•—: {e}");
-                        None
-                    }
-                }
-            } else {
-                None
-            };
-
-            match target.target_type {
-                TargetType::File => {
-                    if target.path.exists() {
-                        // é™¤å¤–ãƒ•ã‚£ãƒ«ã‚¿ãƒã‚§ãƒƒã‚¯
-                        if let Some(ref f) = filter {
-                            if f.should_exclude(&target.path) {
-                                continue;
-                            }
-                        }
-
-                        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ100GBè¶…ã®è­¦å‘Šï¼‰
-                        if let Ok(metadata) = target.path.metadata() {
-                            let file_size = metadata.len();
-                            const LARGE_FILE_THRESHOLD: u64 = 100 * 1024 * 1024 * 1024; // 100GB
-
-                            if file_size > LARGE_FILE_THRESHOLD {
-                                eprintln!(
-                                    "âš ï¸  è­¦å‘Š: å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º ({}GB): {:?}",
-                                    file_size / (1024 * 1024 * 1024),
-                                    target.path
-                                );
-                                eprintln!("    ãƒ¡ãƒ¢ãƒªä¸è¶³ã®ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™ãŒã€ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã‚’æ¨å¥¨ã—ã¾ã™ã€‚");
-                            }
-                        }
-
-                        // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å®‰å…¨ã«å–å¾—ã—ã¦ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å…ˆã‚’æ±ºå®š
-                        if let Some(file_name) = target.path.file_name() {
-                            // safe_joinã‚’ä½¿ç”¨ã—ã¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–
-                            match safe_join(&backup_dir, std::path::Path::new(file_name)) {
-                                Ok(dest) => all_files.push((target.path.clone(), dest)),
-                                Err(e) => eprintln!("è­¦å‘Š: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}"),
-                            }
-                        }
-                    }
-                }
-                TargetType::Directory => {
-                    for entry in WalkDir::new(&target.path)
-                        .into_iter()
-                        .filter_map(std::result::Result::ok)
-                    {
-                        if entry.file_type().is_file() {
-                            let source = entry.path().to_path_buf();
-
-                            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ100GBè¶…ã®è­¦å‘Šï¼‰
-                            if let Ok(metadata) = entry.metadata() {
-                                let file_size = metadata.len();
-                                const LARGE_FILE_THRESHOLD: u64 = 100 * 1024 * 1024 * 1024; // 100GB
-
-                                if file_size > LARGE_FILE_THRESHOLD {
-                                    eprintln!(
-                                        "âš ï¸  è­¦å‘Š: å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º ({}GB): {:?}",
-                                        file_size / (1024 * 1024 * 1024),
-                                        source
-                                    );
-                                    eprintln!("    ãƒ¡ãƒ¢ãƒªä¸è¶³ã®ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™ãŒã€ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã‚’æ¨å¥¨ã—ã¾ã™ã€‚");
-                                }
-                            }
-
-                            // ç›¸å¯¾ãƒ‘ã‚¹ã‚’ä¿æŒã—ã¦ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å…ˆã‚’æ±ºå®šï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ç‰ˆï¼‰
-                            match source.strip_prefix(&target.path) {
-                                Ok(relative) => {
-                                    // é™¤å¤–ãƒ•ã‚£ãƒ«ã‚¿ãƒã‚§ãƒƒã‚¯ï¼ˆç›¸å¯¾ãƒ‘ã‚¹ã«å¯¾ã—ã¦ï¼‰
-                                    if let Some(ref f) = filter {
-                                        if f.should_exclude(relative) {
-                                            continue;
-                                        }
-                                    }
-
-                                    // safe_joinã‚’ä½¿ç”¨ã—ã¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–
-                                    match safe_join(&backup_dir, relative) {
-                                        Ok(dest) => all_files.push((source, dest)),
-                                        Err(e) => {
-                                            eprintln!("è­¦å‘Š: ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«æ¤œå‡ºã€ã‚¹ã‚­ãƒƒãƒ—: {e}")
-                                        }
-                                    }
-                                }
-                                Err(e) => {
-                                    eprintln!("è­¦å‘Š: ãƒ‘ã‚¹ã®strip_prefixã«å¤±æ•—: {e}");
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        // ã‚¹ãƒ”ãƒŠãƒ¼å®Œäº†
-        if let Some(spinner) = collection_spinner {
-            spinner.finish(&format!("{}ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º", all_files.len()));
-        }
-
-        // å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‡¦ç†
-        let inc_engine = IncrementalBackupEngine::new(dest_base.clone());
-        let backup_type = if self.incremental {
-            inc_engine.determine_backup_type()?
-        } else {
-            BackupType::Full
-        };
-
-        // å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®å ´åˆã€å‰å›ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆå¤±æ•—ã—ãŸå ´åˆã¯ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
-        let (actual_backup_type, parent_backup_name, files_to_backup) = if backup_type
-            == BackupType::Incremental
-        {
-            match inc_engine.load_previous_metadata() {
-                Ok(previous_metadata) => {
-                    println!("ğŸ“¦ å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ï¼‰");
-
-                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’è¨ˆç®—
-                    let files_with_relative: Vec<(PathBuf, PathBuf)> = all_files
-                        .iter()
-                        .filter_map(|(source, dest)| {
-                            dest.strip_prefix(&backup_base)
-                                .ok()
-                                .map(|rel| (rel.to_path_buf(), source.clone()))
-                        })
-                        .collect();
-
-                    let changed_files_relative = inc_engine
-                        .detect_changed_files(&files_with_relative, &previous_metadata)?;
-
-                    // å…ƒã®all_fileså½¢å¼ã«æˆ»ã™ï¼ˆsource, destï¼‰
-                    let changed_files: Vec<(PathBuf, PathBuf)> = changed_files_relative
-                        .iter()
-                        .filter_map(|(_relative_path, source_path)| {
-                            all_files
-                                .iter()
-                                .find(|(src, _)| src == source_path)
-                                .cloned()
-                        })
-                        .collect();
-
-                    let parent_name = inc_engine.get_previous_backup_name()?;
-                    println!("  å‰å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: {parent_name:?}");
-                    println!(
-                        "  å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ•°: {}/{}",
-                        changed_files.len(),
-                        all_files.len()
-                    );
-
-                    (BackupType::Incremental, parent_name, changed_files)
-                }
-                Err(e) => {
-                    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å†…å®¹ã§åˆå›å®Ÿè¡Œæ™‚ã‹å®Ÿéš›ã®ã‚¨ãƒ©ãƒ¼ã‹ã‚’åˆ¤åˆ¥
-                    let error_msg = e.to_string();
-                    if error_msg.contains("å‰å›ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
-                        || error_msg.contains("å‰å›ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—")
-                    {
-                        // åˆå›å®Ÿè¡Œæ™‚: æƒ…å ±ãƒ¬ãƒ™ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
-                        println!("â„¹ï¸  å‰å›ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚");
-                    } else {
-                        // å®Ÿéš›ã®ã‚¨ãƒ©ãƒ¼æ™‚ï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç ´æãªã©ï¼‰: è­¦å‘Šãƒ¬ãƒ™ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
-                        eprintln!("âš ï¸  å‰å›ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚");
-                        eprintln!("   è©³ç´°: {e}");
-                    }
-                    println!("ğŸ“¦ ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ï¼ˆå…¨ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰");
-                    (BackupType::Full, None, all_files.clone())
-                }
-            }
-        } else {
-            // --incremental ãƒ•ãƒ©ã‚°ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãŒã€å‰å›ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒãªã„å ´åˆ
-            if self.incremental {
-                println!("â„¹ï¸  å‰å›ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚");
-            }
-            println!("ğŸ“¦ ãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ï¼ˆå…¨ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰");
-            (BackupType::Full, None, all_files.clone())
-        };
-
-        let total_files = files_to_backup.len();
-
-        if self.dry_run {
-            println!("ğŸ“‹ ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³ãƒ¢ãƒ¼ãƒ‰: {total_files} ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ã¨ã—ã¦æ¤œå‡º");
-            for (_source, _dest) in &files_to_backup {
-                println!("  _source.display() â†’ _dest.display()");
-            }
-            return Ok(BackupResult {
-                total_files,
-                successful: 0,
-                failed: 0,
-                total_bytes: 0,
-                errors: Vec::new(),
-                backup_name,
-            });
-        }
-
-        // ProcessingPipelineã®ä½œæˆï¼ˆæš—å·åŒ–ã¾ãŸã¯åœ§ç¸®ãŒæœ‰åŠ¹ãªå ´åˆï¼‰
-        let pipeline = if self.enable_encryption || self.compression_type != CompressionType::None {
-            // CompressionConfigã‚’ä½œæˆï¼ˆcompression_typeã«å¿œã˜ãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰levelã‚’å¤‰æ›´ï¼‰
-            let mut compression_config = match self.compression_type {
-                CompressionType::Zstd => crate::compression::CompressionConfig::zstd_default(),
-                CompressionType::Gzip => crate::compression::CompressionConfig::gzip_default(),
-                CompressionType::None => crate::compression::CompressionConfig::none(),
-            };
-            compression_config.level = self.compression_level;
-
-            let mut config = PipelineConfig::default()
-                .with_compression(self.compression_type, compression_config);
-
-            if self.enable_encryption {
-                config = config.with_encryption(EncryptionConfig::default());
-            }
-
-            Some(Arc::new(ProcessingPipeline::new(config)))
-        } else {
-            None
-        };
-
-        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®åˆæœŸåŒ–
-        let progress = if self.show_progress {
-            Some(Arc::new(BackupProgress::new(total_files as u64)))
-        } else {
-            None
-        };
-
-        // CopyEngineã®åˆæœŸåŒ–ï¼ˆI/Oæœ€é©åŒ–ï¼‰
-        let copy_engine = Arc::new(CopyEngine::new());
-
-        // æ•´åˆæ€§æ¤œè¨¼ãƒã‚§ãƒƒã‚«ãƒ¼ã®åˆæœŸåŒ–
-        let integrity_checker = if self.verify_integrity {
-            Some(Arc::new(std::sync::Mutex::new(IntegrityChecker::new())))
-        } else {
-            None
-        };
-
-        // ä¸¦åˆ—ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‡¦ç†
-        let success_count = AtomicUsize::new(0);
-        let failed_count = AtomicUsize::new(0);
-        let total_bytes = AtomicUsize::new(0);
-
-        let errors: Vec<String> = files_to_backup
-            .par_iter()
-            .filter_map(|(source, dest)| {
-                // é€²æ—è¡¨ç¤ºæ›´æ–°
-                if let Some(ref pb) = progress {
-                    if let Some(file_name) = source.file_name() {
-                        pb.set_message(&format!("å‡¦ç†ä¸­: {file_name:?}"));
-                    }
-                }
-
-                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’è¨ˆç®—ï¼ˆæ•´åˆæ€§æ¤œè¨¼ç”¨ï¼‰
-                let relative_path = dest.strip_prefix(&backup_base).ok();
-
-                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å…ˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
-                if let Some(parent) = dest.parent() {
-                    if let Err(e) = std::fs::create_dir_all(parent) {
-                        failed_count.fetch_add(1, Ordering::Relaxed);
-                        if let Some(ref pb) = progress {
-                            pb.inc(1);
-                        }
-                        return Some(format!("ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆå¤±æ•— parent.display(): {e}"));
-                    }
-                }
-
-                // ProcessingPipelineã¾ãŸã¯CopyEngineã§ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
-                let copy_result = if let Some(ref pipeline) = pipeline {
-                    // æš—å·åŒ–ãƒ»åœ§ç¸®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½¿ç”¨
-                    match pipeline.process_file(
-                        source,
-                        master_key.as_ref().map(std::convert::AsRef::as_ref),
-                        encryption_salt,
-                    ) {
-                        Ok(processed) => {
-                            // å‡¦ç†å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
-                            match std::fs::write(dest, &processed.data) {
-                                Ok(_) => {
-                                    success_count.fetch_add(1, Ordering::Relaxed);
-                                    total_bytes.fetch_add(
-                                        processed.metadata.final_size as usize,
-                                        Ordering::Relaxed,
-                                    );
-                                    if let Some(ref pb) = progress {
-                                        pb.inc(1);
-                                    }
-                                    Ok(())
-                                }
-                                Err(e) => {
-                                    failed_count.fetch_add(1, Ordering::Relaxed);
-                                    if let Some(ref pb) = progress {
-                                        pb.inc(1);
-                                    }
-                                    Err(format!("æ›¸ãè¾¼ã¿å¤±æ•— dest.display(): {e}"))
-                                }
-                            }
-                        }
-                        Err(e) => {
-                            failed_count.fetch_add(1, Ordering::Relaxed);
-                            if let Some(ref pb) = progress {
-                                pb.inc(1);
-                            }
-                            Err(format!("å‡¦ç†å¤±æ•— source.display(): {e}"))
-                        }
-                    }
-                } else {
-                    // å¾“æ¥ã®CopyEngineä½¿ç”¨ï¼ˆæš—å·åŒ–ãƒ»åœ§ç¸®ãªã—ï¼‰
-                    match copy_engine.copy_file(source, dest) {
-                        Ok(bytes) => {
-                            success_count.fetch_add(1, Ordering::Relaxed);
-                            total_bytes.fetch_add(bytes as usize, Ordering::Relaxed);
-                            if let Some(ref pb) = progress {
-                                pb.inc(1);
-                            }
-                            Ok(())
-                        }
-                        Err(e) => {
-                            failed_count.fetch_add(1, Ordering::Relaxed);
-                            if let Some(ref pb) = progress {
-                                pb.inc(1);
-                            }
-                            Err(format!("ã‚³ãƒ”ãƒ¼å¤±æ•— source.display(): {e}"))
-                        }
-                    }
-                };
-
-                // æ•´åˆæ€§æ¤œè¨¼ï¼šå…ƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ã—ã¦ä¿å­˜
-                if copy_result.is_ok() {
-                    if let Some(ref checker) = integrity_checker {
-                        if let Some(rel_path) = relative_path {
-                            if let Ok(mut guard) = checker.lock() {
-                                if let Ok(hash) = guard.compute_hash(source) {
-                                    guard.add_file_hash(rel_path.to_path_buf(), hash);
-                                }
-                            }
-                        }
-                    }
-                }
-
-                copy_result.err()
-            })
-            .collect();
-
-        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼å®Œäº†
-        if let Some(pb) = progress {
-            let failed = failed_count.load(Ordering::Relaxed);
-            if failed == 0 {
-                pb.finish("âœ“ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†");
-            } else {
-                pb.finish(&format!("âš  ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†ï¼ˆ{failed}ä»¶å¤±æ•—ï¼‰"));
-            }
-        }
-
-        // æ•´åˆæ€§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆå¢—åˆ†æƒ…å ±ã‚’å«ã‚€ï¼‰
-        if let Some(ref checker) = integrity_checker {
-            if let Ok(mut guard) = checker.lock() {
-                // å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±ã‚’è¿½åŠ 
-                guard.metadata.backup_type = actual_backup_type;
-                guard.metadata.parent_backup = parent_backup_name;
-                guard.metadata.changed_files = files_to_backup
-                    .iter()
-                    .filter_map(|(_, dest)| {
-                        dest.strip_prefix(&backup_base)
-                            .ok()
-                            .map(std::path::Path::to_path_buf)
-                    })
-                    .collect();
-
-                // å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®å ´åˆã€å¤‰æ›´ã•ã‚Œãªã‹ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã‚‚ä¿å­˜
-                // ï¼ˆæ¬¡å›ã®å¢—åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã§æ­£ã—ãæ¯”è¼ƒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼‰
-                if actual_backup_type == BackupType::Incremental {
-                    for (source, dest) in &all_files {
-                        if let Ok(rel_path) = dest.strip_prefix(&backup_base) {
-                            // æ—¢ã«ãƒãƒƒã‚·ãƒ¥ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
-                            if !guard.metadata.file_hashes.contains_key(rel_path) {
-                                if let Ok(hash) = guard.compute_hash(source) {
-                                    guard.add_file_hash(rel_path.to_path_buf(), hash);
-                                }
-                            }
-                        }
-                    }
-                }
-
-                if let Err(e) = guard.save_metadata(&backup_base) {
-                    eprintln!("è­¦å‘Š: æ•´åˆæ€§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}");
-                }
-            }
-        }
-
-        let result = BackupResult {
-            total_files,
-            successful: success_count.load(Ordering::Relaxed),
-            failed: failed_count.load(Ordering::Relaxed),
-            total_bytes: total_bytes.load(Ordering::Relaxed) as u64,
-            errors,
-            backup_name,
-        };
-
-        // å±¥æ­´ä¿å­˜ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å…¨ä½“ã®ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ç”¨ï¼‰
-        let success = result.failed == 0;
-        if let Err(e) = super::BackupHistory::save(&super::BackupHistory::new(
-            backup_base.clone(),
-            result.total_files,
-            result.total_bytes,
-            success,
-        )) {
-            eprintln!("å±¥æ­´ä¿å­˜å¤±æ•—: {e}");
-        }
-
-        // ç›£æŸ»ãƒ­ã‚°: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº† or å¤±æ•—
-        if let Some(ref mut audit_log) = self.audit_log {
-            let metadata = serde_json::json!({
-                "total_files": result.total_files,
-                "successful": result.successful,
-                "failed": result.failed,
-                "total_bytes": result.total_bytes,
-                "backup_name": result.backup_name,
-            });
-
-            let event = if success {
-                AuditEvent::backup_completed(&target_desc, &user, metadata)
-            } else {
-                AuditEvent::backup_failed(
-                    &target_desc,
-                    &user,
-                    format!("{}ä»¶ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", result.failed),
-                )
-            };
-
-            let _ = audit_log
-                .log(event)
-                .map_err(|e| eprintln!("è­¦å‘Š: ç›£æŸ»ãƒ­ã‚°ã®è¨˜éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}"));
-        }
-
-        Ok(result)
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
     use std::fs::File;
     use std::io::Write;
